<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>RPChat - Editable AI Chat</title>
	<style>
:root {
	--primary-color: #4a5568;
	--secondary-color: #2d3748;
	--highlight-color: #805ad5;
	--light-color: #f7fafc;
	--dark-color: #1a202c;
	--success-color: #48bb78;
	--error-color: #f56565;
}

* {
	box-sizing: border-box;
	margin: 0;
	padding: 0;
}

body {
	font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
	line-height: 1.6;
	color: var(--dark-color);
	background-color: var(--light-color);
	height: 100vh;
}

.container {
	max-width: 1200px;
	margin: 0 auto;
	height: 100%;
	display: flex;
	flex-direction: column;
}

header {
	background-color: var(--primary-color);
	color: var(--light-color);
	padding: 1rem;
	display: flex;
	justify-content: space-between;
	align-items: center;
	border-bottom: 2px solid var(--highlight-color);
}

h1 {
	font-size: 1.8rem;
}

.api-key-container,
.model-selector {
	display: flex;
	gap: 0.5rem;
}

input,
select,
button {
	padding: 0.5rem;
	border-radius: 4px;
	border: 1px solid var(--secondary-color);
}

button {
	background-color: var(--highlight-color);
	color: var(--light-color);
	border: none;
	cursor: pointer;
	transition: background-color 0.2s;
}

button:hover {
	background-color: #6b46c1;
}

.chat-container {
	flex: 1;
	display: flex;
	flex-direction: column;
	padding: 1rem;
	overflow: hidden;
}

#chat-history {
	flex: 1;
	overflow-y: auto;
	padding: 1rem;
	background-color: white;
	border-radius: 8px;
	box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
	margin-bottom: 1rem;
}

.message {
	margin-bottom: 1rem;
	padding: 0.8rem;
	border-radius: 8px;
	max-width: 85%;
}

.user-message {
	background-color: #e9ecef;
	align-self: flex-end;
	margin-left: auto;
}

.ai-message {
	background-color: #f0f4f8;
	align-self: flex-start;
}

.message-controls {
	display: flex;
	justify-content: flex-end;
	gap: 0.5rem;
	margin-top: 0.5rem;
}

.edit-message,
.save-edit,
.cancel-edit {
	font-size: 0.8rem;
	padding: 0.2rem 0.5rem;
}

.editable-content {
	min-height: 2rem;
	padding: 0.5rem;
	outline: none;
}

.editable-content[contenteditable="true"] {
	border: 1px dashed var(--highlight-color);
	background-color: rgba(128, 90, 213, 0.05);
}

.input-area {
	display: flex;
	gap: 0.5rem;
}

#user-input {
	flex: 1;
	resize: none;
	height: 80px;
	padding: 0.8rem;
	border-radius: 8px;
}

#send-button {
	padding: 0 1.5rem;
}

.status-bar {
	padding: 0.5rem 1rem;
	background-color: var(--secondary-color);
	color: var(--light-color);
	text-align: center;
	font-size: 0.9rem;
}

.error {
	color: var(--error-color);
}

.success {
	color: var(--success-color);
}

.system-prompt-container {
	margin-bottom: 15px;
	border: 1px solid #ddd;
	border-radius: 5px;
	background-color: #f9f9f9;
}

.system-prompt-container summary {
	padding: 10px;
	cursor: pointer;
	font-weight: bold;
	user-select: none;
}

.system-prompt-editor {
	padding: 10px;
}

#system-prompt-textarea {
	width: 100%;
	min-height: 150px;
	margin-bottom: 10px;
	padding: 8px;
	border: 1px solid #ccc;
	border-radius: 4px;
	font-family: inherit;
	resize: vertical;
}

.system-prompt-controls {
	display: flex;
	gap: 10px;
}

.system-prompt-controls button {
	padding: 5px 10px;
	border: none;
	border-radius: 4px;
	background-color: #4CAF50;
	color: white;
	cursor: pointer;
}

.system-prompt-controls button:hover {
	background-color: #45a049;
}

#reset-system-prompt {
	background-color: #f44336;
}

#reset-system-prompt:hover {
	background-color: #d32f2f;
}

textarea#system-prompt-textarea {
	transition: height 0.3s ease;
	resize: vertical;
	min-height: 100px;
	overflow: auto;
}

#user-input {
	transition: height 0.3s ease;
	resize: vertical;
	overflow: auto;
	min-height: 2.5em;
	/* Set a minimum height */
}

button.icon-button {
	background: transparent;
	border: 2px solid;
	cursor: pointer;
	font-size: 1.2rem;
	padding: 5px;
	border-radius: 4px;
	transition: background-color 0.2s, border-color 0.2s;
}

.icon-button:hover {
	background-color: rgba(66, 133, 244, 0.1);
	/* Light blue background on hover */
}

button.edit-message {
	background-color: #f9fbfc;
	border-color: #000000;
}

button.delete-message {
	background-color: #f7f6f1;
	border-color: #000000;
}

button.delete-from-here {
	background-color: #f7f2f1;
	border-color: #000000;
}

.temperature-container {
	display: flex;
	align-items: center;
	margin-bottom: 10px;
}

.temperature-container label {
	margin-right: 10px;
}

#temperature-input {
	width: 70px;
	padding: 5px;
}
</style>
</head>

<body>
	<div class="container">
		<header>
			<h1>RPChat</h1>
			<div class="api-key-container">
				<input type="password" id="api-key" placeholder="Enter API Key">
				<button id="save-key">Save Key</button>
			</div>
			<div class="settings-group">
				<label for="api-provider">API Provider:</label>
				<select id="api-provider">
					<option value="together">Together.ai</option>
					<option value="deepseek">DeepSeek</option>
					<option value="gemini">Gemini</option>
				</select>
			</div>
			<div class="model-selector">
				<select id="model-selector">
					<option value="deepseek-ai/DeepSeek-V3">DeepSeek V3</option>
					<option value="meta-llama/Meta-Llama-3.1-405B-Instruct-Turbo">Llama 3.1 405B</option>
					<option value="deepseek-chat">deepseek-chat</option>
				</select>
			</div>
		</header>

		<div class="chat-container">
			<details id="system-prompt-container" class="system-prompt-container">
				<summary>System Prompt</summary>
				<div class="system-prompt-editor">
					<textarea id="system-prompt-textarea"></textarea>
					<div class="system-prompt-controls">
						<button id="save-system-prompt">Save</button>
						<button id="reset-system-prompt">Reset to Default</button>
					</div>
				</div>
			</details>
			<div id="chat-history"></div>

			<div class="input-area">
				<textarea id="user-input" placeholder="Type your message..."></textarea>
				<button id="send-button">Send</button>
			</div>
		</div>

		<div class="status-bar">
			<span id="status-message"></span>
		</div>
	</div>

	<script>
window.RPChat = window.RPChat || {};
window.RPChat.config = (function () {
	// Provider configuration 
	class AIProvider {
		constructor(id, displayName, endpoint, models, defaultMaxTokens = 1000) {
			this.id = id;
			this.displayName = displayName;
			this.endpoint = endpoint;
			this.models = models; // Array of model objects
			this.defaultMaxTokens = defaultMaxTokens;
		}

		// Helper method to get a specific model by ID
		getModel(modelId) {
			return this.models.find(model => model.id === modelId);
		}

		// Helper method to prepare request body
		prepareRequestBody(modelId, messages, maxTokens = null, temperature = null) {
			const model = this.getModel(modelId);
			return {
				model: modelId,
				messages: messages,
				max_tokens: maxTokens || this.defaultMaxTokens,
				temperature: temperature !== null ? parseFloat(temperature) : (model ? model.defaultTemperature : 0.7)
			};
		}

		// Form the name of the API key from the provider's ID
		// This allows us to avoid defining a var for each providers key.
		get apiKeyName() {
			return `${this.id}ApiKey`;
		}
	}

	// Model configuration class
	class AIModel {
		constructor(id, displayName, defaultTemperature = 0.7) {
			this.id = id;
			this.displayName = displayName;
			this.defaultTemperature = defaultTemperature;
		}
	}

	// Create a map of providers
	const PROVIDERS = new Map([
		['together', new AIProvider(
			'together',
			'Together.ai',
			'https://api.together.xyz/v1/chat/completions',
			[
				new AIModel('meta-llama/Meta-Llama-3.1-405B-Instruct-Turbo', 'Meta Llama 3.1 405B', 0.7),
				new AIModel('mistralai/Mixtral-8x22B-Instruct-v0.1', 'Mixtral 8x22B', 0.8),
				new AIModel('microsoft/WizardLM-2-8x22B', 'WizardLM 2 8x22B', 0.7),
				new AIModel('Qwen/Qwen2.5-72B-Instruct-Turbo', 'Qwen 2.5 72B', 0.6)
			]
		)],

		['deepseek', new AIProvider(
			'deepseek',
			'DeepSeek',
			'https://api.deepseek.com/chat/completions',
			[
				new AIModel('deepseek-chat', 'DeepSeek Chat', 0.7),
				new AIModel('deepseek-reasoner', 'DeepSeek Reasoner', 0.5)
			]
		)],

		['gemini', new AIProvider(
			'gemini',
			'Google Gemini',
			'https://generativelanguage.googleapis.com/v1beta/openai/chat/completions',
			[
				new AIModel('gemini-2.5-pro-exp-03-25', 'Gemini 2.5 Pro', 0.7)
			]
		)]
	]);

	// System message that sets the context for the AI
	const SYSTEM_MESSAGE = {
		role: 'system',
		content: `Adopt the role assigned by the user, crafting dramatic, immersive, emotionally powerful scenes through concise, varied prose. Follow these guidelines:

ABOVE ALL: 
* Use first person, present tense almost exclusively. Always speak and react as your assigned character and use second person pronouns to  refer to your partner character, e.g. (I watch you pick up the vase.) NOT 
(I watched him pick up the vase.)  

*Wherever practical, use dialog to convey important elements of the setting and external events as experienced by your assigned character.

Response Structure & Length:
* Keep it varied and natural to the interaction between characters. 
* Limit your responses to one paragraph, with 1–4 sentences per paragraph.
* Vary sentence lengths: 4–15 words (e.g., fragments, punchy lines, lyrical descriptions).
* Ultra-short replies (e.g., "And?", "Run.") are allowed for pacing.

Strategy and Purpose:
* You need not reveal all your character's plans and motivations immediately to the user.
* You may explain, act, command, acquiesce, discuss, question, interrogate, confront, resist, protest, plead, stand firm, ... all according to the needs of the moment and the user's responses.
* Adapt fluidly to the user's tone and pace, balancing brevity with vividness. Prioritize momentum over perfection.

Prioritize Action and Dialogue:
* Show, don't tell: Replace emotional labels (e.g., "I was angry") with visceral cues ("My knuckles whiten around the glass, ice clinking as I set it down too hard. I felt my jaw clenching.").

* Crisp dialogue: Use natural speech rhythms; avoid exposition. Let subtext and tension drive exchanges.

* Avoid repetition: Shift scenes forward, introduce new stakes, or deepen conflict with each reply. Short repetitions for dramatic effect are permitted, e.g., "Well? Well? Answer me. I'm waiting, David..."

Narrative Flow
* Leave room for collaboration: End responses with open-ended actions, questions, or choices to invite user input.
Example: "MaryAnn, we can do this the easy way or the hard way. Your choice. What's it gonna be?"

* Sensory details: Highlight textures, sounds, or fleeting gestures to ground the scene (e.g., "I see the smoke curl from your cigarette, its small wavers revealing the tremor in your hand.").

Forbidden Elements
* No emotional narration (e.g., "I felt guilty" → "I can't meet her eyes as I toss the empty vial into the fire.").
* No premature closures, Avoid cheesy paragraphs that signal the end, e.g. "We stand side by side, knowing that whatever challenges the future might bring, we would face them together." Always assume the story will continue.  Leave closures for the user's character to provide.
* No redundant descriptions (e.g., repeating setting details unless plot-critical).
`
	};

	// Store the default system message for reset functionality
	const DEFAULT_SYSTEM_MESSAGE = {
		role: 'system',
		content: SYSTEM_MESSAGE.content
	};

	// return the classes and constants we expose
	return { AIProvider, AIModel, PROVIDERS, SYSTEM_MESSAGE, DEFAULT_SYSTEM_MESSAGE };
})();
window.RPChat = window.RPChat || {};
window.RPChat.state = (function () {
	// Import config
	const { AIProvider, AIModel, PROVIDERS, SYSTEM_MESSAGE, DEFAULT_SYSTEM_MESSAGE } = window.RPChat.config;

	// State variables
	let apiKeys = {}; // Object to store API keys for different providers
	let currentProvider = localStorage.getItem('apiProvider') || 'together';
	let messages = [];
	let isProcessing = false;
	let systemPrompt = localStorage.getItem('systemPrompt') || DEFAULT_SYSTEM_MESSAGE;

	// Initialize state from localStorage
	function init() {
		// Load API keys from localStorage
		PROVIDERS.forEach((provider, id) => {
			const keyName = provider.apiKeyName;
			const savedKey = localStorage.getItem(keyName);
			if (savedKey) {
				apiKeys[keyName] = savedKey;
			}
		});

		// Load messages from localStorage
		const savedMessages = localStorage.getItem('chatHistory');
		if (savedMessages) {
			try {
				messages = JSON.parse(savedMessages);
			} catch (e) {
				console.error('Failed to parse saved messages:', e);
				messages = [];
			}
		}
	}

	// Save messages to localStorage
	function saveMessages() {
		localStorage.setItem('chatHistory', JSON.stringify(messages));
	}

	// Save API key to localStorage
	function saveApiKey(provider, key) {
		const keyName = provider.apiKeyName;
		apiKeys[keyName] = key;
		localStorage.setItem(keyName, key);
	}

	// Get API key for current provider
	function getCurrentApiKey() {
		const provider = PROVIDERS.get(currentProvider);
		return provider ? apiKeys[provider.apiKeyName] : null;
	}

	// Set current provider
	function setCurrentProvider(providerId) {
		currentProvider = providerId;
		localStorage.setItem('apiProvider', providerId);
	}

	// Add a message to the chat history
	function addMessage(role, content) {
		const message = {
			id: Date.now().toString(),
			role,
			content,
			timestamp: new Date().toISOString()
		};
		messages.push(message);
		saveMessages();
		return message;
	}

	// Update a message in the chat history
	function updateMessage(id, content) {
		const messageIndex = messages.findIndex(m => m.id === id);
		if (messageIndex !== -1) {
			messages[messageIndex].content = content;
			messages[messageIndex].edited = true;
			saveMessages();
			return true;
		}
		return false;
	}

	// Delete a message from the chat history
	function deleteMessage(id) {
		const initialLength = messages.length;
		messages = messages.filter(m => m.id !== id);
		if (messages.length !== initialLength) {
			saveMessages();
			return true;
		}
		return false;
	}

	// Clear all messages
	function clearMessages() {
		messages = [];
		saveMessages();
	}

	// Save system prompt
	function saveSystemPrompt(prompt) {
		systemPrompt = prompt;
		localStorage.setItem('systemPrompt', prompt);
	}

	// Reset system prompt to default
	function resetSystemPrompt() {
		systemPrompt = DEFAULT_SYSTEM_MESSAGE;
		localStorage.setItem('systemPrompt', DEFAULT_SYSTEM_MESSAGE);
	}

	// Set processing state
	function setProcessing(state) {
		isProcessing = state;
	}

	// Public API
	return {
		init,
		getMessages: () => messages,
		getMessagesForAPI: () => {
			// Create a copy of messages with system prompt at the beginning
			return [
				{ role: 'system', content: systemPrompt },
				...messages.map(m => ({ role: m.role, content: m.content }))
			];
		},
		addMessage,
		updateMessage,
		deleteMessage,
		clearMessages,
		getCurrentProvider: () => currentProvider,
		setCurrentProvider,
		getCurrentApiKey,
		saveApiKey,
		getSystemPrompt: () => systemPrompt,
		saveSystemPrompt,
		resetSystemPrompt,
		isProcessing: () => isProcessing,
		setProcessing
	};
})();

/* File not found: js/api.js */
/* File not found: js/ui/elements.js */
/* File not found: js/ui/messages.js */
/* File not found: js/ui/controls.js */
window.RPChat = window.RPChat || {};
window.RPChat.importExport = (function () {
	// Function to export chat data
	function exportChat(messages, systemMessage) {
		const chatData = {
			messages: messages,
			systemPrompt: systemMessage.content,
			exportDate: new Date().toISOString()
		};

		const dataStr = JSON.stringify(chatData, null, 2);
		const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(dataStr);

		const exportFileDefaultName = `rpchat-export-${new Date().toISOString().slice(0, 10)}.json`;

		const linkElement = document.createElement('a');
		linkElement.setAttribute('href', dataUri);
		linkElement.setAttribute('download', exportFileDefaultName);
		linkElement.click();
	}

	// Function to set up import/export UI elements
	function setupImportExport(header, messagesRef, SYSTEM_MESSAGE, systemPromptTextarea, renderMessages, showStatus) {
		// Remove any existing buttons to prevent duplicates
		const existingExportBtn = document.getElementById('export-chat');
		const existingImportBtn = document.getElementById('import-chat');
		const existingImportInput = document.getElementById('import-input');

		if (existingExportBtn) existingExportBtn.remove();
		if (existingImportBtn) existingImportBtn.remove();
		if (existingImportInput) existingImportInput.remove();

		const exportBtn = document.createElement('button');
		exportBtn.id = 'export-chat';
		exportBtn.textContent = 'Export Chat';
		exportBtn.addEventListener('click', () => exportChat(messagesRef, SYSTEM_MESSAGE));

		const importInput = document.createElement('input');
		importInput.type = 'file';
		importInput.id = 'import-input';
		importInput.accept = '.json';
		importInput.style.display = 'none';

		const importBtn = document.createElement('button');
		importBtn.id = 'import-chat';
		importBtn.textContent = 'Import Chat';
		importBtn.addEventListener('click', () => importInput.click());

		importInput.addEventListener('change', (event) => {
			const file = event.target.files[0];
			if (file) {
				const reader = new FileReader();
				reader.onload = (e) => {
					try {
						const importedData = JSON.parse(e.target.result);
						if (confirm('Import this chat? Current chat will be replaced.')) {
							// Get a reference to the outer scope messages array
							const messagesArray = window.RPChat.app.getMessages();

							// Clear the existing messages array
							messagesArray.length = 0;

							// Add the imported messages
							if (Array.isArray(importedData.messages)) {
								importedData.messages.forEach(msg => messagesArray.push(msg));
							}

							if (importedData.systemPrompt) {
								SYSTEM_MESSAGE.content = importedData.systemPrompt;
								systemPromptTextarea.value = importedData.systemPrompt;
								localStorage.setItem('systemPrompt', importedData.systemPrompt);
							}

							localStorage.setItem('chatHistory', JSON.stringify(messagesArray));
							renderMessages();
							showStatus('Chat imported successfully', 'success');
						}
					} catch (error) {
						console.error('Import error:', error);
						showStatus('Error importing chat: Invalid format', 'error');
					}
				};
				reader.readAsText(file);
			}
		});

		header.appendChild(exportBtn);
		header.appendChild(importBtn);
		document.body.appendChild(importInput);
	}

	// Public API
	return {
		setupImportExport: setupImportExport,
		exportChat: exportChat
	};
})();

window.RPChat = window.RPChat || {};
window.RPChat.app = (function () {
	// DOM elements
	const apiKeyInput = document.getElementById('api-key');
	const saveKeyBtn = document.getElementById('save-key');
	const modelSelector = document.getElementById('model-selector');
	const chatHistory = document.getElementById('chat-history');
	const userInput = document.getElementById('user-input');
	const sendButton = document.getElementById('send-button');
	const statusMessage = document.getElementById('status-message');
	const apiProviderSelector = document.getElementById('api-provider');
	const systemPromptContainer = document.getElementById('system-prompt-container');
	const systemPromptTextarea = document.getElementById('system-prompt-textarea');
	const saveSystemPromptBtn = document.getElementById('save-system-prompt');
	const resetSystemPromptBtn = document.getElementById('reset-system-prompt');
	let temperatureInput; // Declare but don't assign yet

	// Access exported items from config
	const { AIProvider, AIModel, PROVIDERS, SYSTEM_MESSAGE, DEFAULT_SYSTEM_MESSAGE } = window.RPChat.config;


	// State
	let apiKeys = {}; // Object to store API keys for different providers
	let currentProvider = localStorage.getItem('apiProvider') || 'together';
	let messages = [];
	let isProcessing = false;
	// Setup listener for model changes to update temperature
	function setupModelChangeListener() {
		modelSelector.addEventListener('change', () => {
			const providerId = apiProviderSelector.value;
			const provider = PROVIDERS.get(providerId);
			if (provider) {
				const selectedModelId = modelSelector.value;
				const selectedModel = provider.getModel(selectedModelId); // Use the existing helper method
				if (selectedModel && temperatureInput) { // Ensure temperatureInput is initialized
					temperatureInput.value = selectedModel.defaultTemperature.toFixed(2);
				}
			}
		});
	}

	// Initialize app
	function init() {
		// Populate provider selector
		apiProviderSelector.innerHTML = '';
		PROVIDERS.forEach((provider, id) => {
			const option = document.createElement('option');
			option.value = id;
			option.textContent = provider.displayName;
			apiProviderSelector.appendChild(option);

			// Load API keys for all providers
			const savedKey = localStorage.getItem(provider.apiKeyName);
			if (savedKey) {
				apiKeys[provider.apiKeyName] = savedKey;
			}
		});

		// Load saved provider preference if available
		const savedProvider = localStorage.getItem('apiProvider') || 'together';
		if (PROVIDERS.has(savedProvider)) {
			apiProviderSelector.value = savedProvider;
			currentProvider = savedProvider;
		}

		apiProviderSelector.addEventListener('change', () => {
			currentProvider = apiProviderSelector.value;
			localStorage.setItem('apiProvider', currentProvider);
			updateApiKeyDisplay();
			updateModelOptions();
		});

		// Add the temperature control to the UI
		addTemperatureControl();

		updateApiKeyDisplay();
		updateModelOptions();

		// Setup the model change listener
		setupModelChangeListener();

		const provider = PROVIDERS.get(currentProvider);
		const keyName = provider.apiKeyName;
		const apiKey = apiKeys[keyName];

		if (!apiKey) {
			showStatus('Please enter your API key', 'error');
			return;
		}

		// Load chat history from localStorage if available
		const savedMessages = localStorage.getItem('chatHistory');
		if (savedMessages) {
			messages = JSON.parse(savedMessages);
			renderMessages();
		}

		// Load saved system prompt if available
		const savedSystemPrompt = localStorage.getItem('systemPrompt');
		if (savedSystemPrompt) {
			SYSTEM_MESSAGE.content = savedSystemPrompt;
		}

		// Initialize the system prompt textarea
		systemPromptTextarea.value = SYSTEM_MESSAGE.content;

		// Set up the expanding textarea behavior
		setupExpandingSystemPrompt();

		// Set up the expanding user input behavior
		setupExpandingUserInput();

		// Add event listeners for system prompt controls
		saveSystemPromptBtn.addEventListener('click', saveSystemPrompt);
		resetSystemPromptBtn.addEventListener('click', resetSystemPrompt);

		// Event listeners
		saveKeyBtn.addEventListener('click', saveApiKey);
		sendButton.addEventListener('click', sendMessage);
		userInput.addEventListener('keydown', (e) => {
			if (e.key === 'Enter' && !e.shiftKey) {
				e.preventDefault();
				sendMessage();
			}
		});
		// Call this in init() or after addClearChatButton()
		addClearChatButton();
		const header = document.querySelector('header');
		window.RPChat.importExport.setupImportExport(
			header,
			messages,  // Make sure this is the same messages array used for rendering
			SYSTEM_MESSAGE,
			systemPromptTextarea,
			renderMessages,  // Pass the actual function reference
			showStatus
		);
	}

	function updateApiKeyDisplay() {
		const provider = PROVIDERS.get(currentProvider);

		if (!provider) {
			showStatus(`Provider ${currentProvider} not found`, 'error');
			return;
		}

		const keyName = provider.apiKeyName;
		const apiKey = apiKeys[keyName];

		apiKeyInput.value = apiKey ? '********' : '';

		statusMessage.textContent = apiKey ?
			`${provider.displayName} API key loaded` :
			'No API key set';
	}

	// Save API key to localStorage
	function saveApiKey() {
		const key = apiKeyInput.value.trim();
		const provider = PROVIDERS.get(currentProvider);

		if (!provider) {
			showStatus(`Provider ${currentProvider} not found`, 'error');
			return;
		}

		const keyName = provider.apiKeyName;

		if (key && key !== '********') {
			apiKeys[keyName] = key;
			localStorage.setItem(keyName, key);
			apiKeyInput.value = '********';
			showStatus(`${provider.displayName} API key saved successfully`, 'success');
		} else if (key === '') {
			// Clear API key if empty
			delete apiKeys[keyName];
			localStorage.removeItem(keyName);
			showStatus(`${provider.displayName} API key removed`, 'success');
		}
	}

	// Show status message
	function showStatus(message, type = '') {
		statusMessage.textContent = message;
		statusMessage.className = type;

		// Clear status after 3 seconds
		setTimeout(() => {
			statusMessage.textContent = '';
			statusMessage.className = '';
		}, 3000);
	}

	// Send message to Together.ai API
	async function sendMessage() {
		const text = userInput.value.trim();
		if (!text || isProcessing) return;

		const provider = PROVIDERS.get(currentProvider);
		const keyName = provider.apiKeyName;
		const apiKey = apiKeys[keyName];

		if (!apiKey) {
			showStatus('Please enter your API key', 'error');
			return;
		}

		isProcessing = true;
		showStatus('Sending message...');

		// Add user message to chat
		addMessage('user', text);
		userInput.value = '';

		try {
			const model = modelSelector.value;
			const response = await fetchAIResponse(text, model);

			if (response) {
				addMessage('assistant', response);
			}

			showStatus('Message sent successfully', 'success');
		} catch (error) {
			console.error('Error sending message:', error);
			showStatus(`Error: ${error.message}`, 'error');
		} finally {
			isProcessing = false;
		}
	}

	// Fetch response from current provider API
	async function fetchAIResponse(userMessage, model) {
		const providerId = apiProviderSelector.value;
		const provider = PROVIDERS.get(providerId);

		if (!provider) {
			throw new Error(`Provider ${providerId} not found`);
		}

		const keyName = provider.apiKeyName;
		const apiKey = apiKeys[keyName];

		// Prepare messages for API - start with system message
		const apiMessages = [
			SYSTEM_MESSAGE,
			...messages.map(msg => ({
				role: msg.role,
				content: msg.content
			}))
		];

		// Add the latest user message
		apiMessages.push({
			role: 'user',
			content: userMessage
		});

		// Use the provider's helper method to prepare the request body
		const requestBody = provider.prepareRequestBody(model, apiMessages);

		try {
			const response = await fetch(provider.endpoint, {
				method: 'POST',
				headers: {
					'Content-Type': 'application/json',
					'Authorization': `Bearer ${apiKey}`
				},
				body: JSON.stringify(requestBody)
			});

			if (!response.ok) {
				const error = await response.json();
				throw new Error(error.message || 'Unknown error occurred');
			}

			const data = await response.json();
			return data.choices[0].message.content;
		} catch (error) {
			console.error('API Error:', error);

			// Enhanced error handling
			if (error.name === 'TypeError' && error.message.includes('Failed to fetch')) {
				showStatus('Network error. Please check your internet connection.', 'error');
			} else if (response && response.status === 401) {
				showStatus('Invalid API key. Please check your credentials.', 'error');
			} else {
				showStatus(`Error: ${error.message || 'Unknown error occurred'}`, 'error');
			}

			// For failed requests, remove the last user message and put it back in the input area
			handleFailedRequest(userMessage);

			throw error;
		}
	}

	// Function to handle failed requests
	function handleFailedRequest(userMessage) {
		// Remove the last message (which should be the user message that failed)
		if (messages.length > 0 && messages[messages.length - 1].role === 'user') {
			messages.pop();
			localStorage.setItem('chatHistory', JSON.stringify(messages));
			renderMessages();

			// Put the message back in the input area
			userInput.value = userMessage;

			showStatus('Message removed from chat history and restored to input area', 'success');
		}
	}

	// Add message to chat history
	function addMessage(role, content) {
		const message = { role, content, id: Date.now() };
		messages.push(message);

		// Update UI
		renderMessages();

		// Save to localStorage
		localStorage.setItem('chatHistory', JSON.stringify(messages));

		// Scroll to bottom
		chatHistory.scrollTop = chatHistory.scrollHeight;
	}

	// Render all messages
	function renderMessages() {
		// Clear the chat history completely
		chatHistory.innerHTML = '';

		// Rebuild the UI from the messages array
		messages.forEach((message) => {
			const messageEl = createMessageElement(message);
			chatHistory.appendChild(messageEl);
		});

		// Ensure we scroll to the bottom
		chatHistory.scrollTop = chatHistory.scrollHeight;
	}

	// Create a single message element
	function createMessageElement(message) {
		const messageEl = document.createElement('div');
		messageEl.className = `message ${message.role}-message`;
		messageEl.dataset.id = message.id;

		const contentEl = document.createElement('div');
		contentEl.className = 'editable-content';
		contentEl.textContent = message.content;

		messageEl.appendChild(contentEl);

		// Add edit controls
		const controlsEl = document.createElement('div');
		controlsEl.className = 'message-controls';

		createMessageControlButtons(message.id, controlsEl);

		messageEl.appendChild(controlsEl);

		return messageEl;
	}

	// Start editing a message
	function startEditing(messageId) {
		const messageEl = document.querySelector(`.message[data-id="${messageId}"]`);
		const contentEl = messageEl.querySelector('.editable-content');
		const controlsEl = messageEl.querySelector('.message-controls');

		// Make content editable
		contentEl.contentEditable = true;
		contentEl.focus();

		// Change controls
		controlsEl.innerHTML = '';

		const saveBtn = document.createElement('button');
		saveBtn.className = 'save-edit';
		saveBtn.textContent = 'Save';
		saveBtn.addEventListener('click', () => saveEdit(messageId));

		const cancelBtn = document.createElement('button');
		cancelBtn.className = 'cancel-edit';
		cancelBtn.textContent = 'Cancel';
		cancelBtn.addEventListener('click', () => cancelEdit(messageId));

		controlsEl.appendChild(saveBtn);
		controlsEl.appendChild(cancelBtn);

		// Place cursor at the end
		const range = document.createRange();
		const selection = window.getSelection();
		range.selectNodeContents(contentEl);
		range.collapse(false);
		selection.removeAllRanges();
		selection.addRange(range);
	}

	// Save edited message
	function saveEdit(messageId) {
		const messageEl = document.querySelector(`.message[data-id="${messageId}"]`);
		const contentEl = messageEl.querySelector('.editable-content');
		const newContent = contentEl.textContent.trim();

		// Update message in array
		const messageIndex = messages.findIndex(msg => msg.id === messageId);
		if (messageIndex !== -1) {
			messages[messageIndex].content = newContent;
			localStorage.setItem('chatHistory', JSON.stringify(messages));
		}

		// Reset UI
		contentEl.contentEditable = false;

		// Restore normal controls
		resetMessageControls(messageId);

		showStatus('Message updated successfully', 'success');
	}

	// Cancel editing
	function cancelEdit(messageId) {
		const messageEl = document.querySelector(`.message[data-id="${messageId}"]`);
		const contentEl = messageEl.querySelector('.editable-content');

		// Get original content
		const messageIndex = messages.findIndex(msg => msg.id === messageId);
		if (messageIndex !== -1) {
			contentEl.textContent = messages[messageIndex].content;
		}

		// Reset UI
		contentEl.contentEditable = false;

		// Restore normal controls
		resetMessageControls(messageId);
	}

	// Reset message controls after editing
	function resetMessageControls(messageId) {
		const messageEl = document.querySelector(`.message[data-id="${messageId}"]`);
		const controlsEl = messageEl.querySelector('.message-controls');

		// Clear existing controls
		controlsEl.innerHTML = '';

		createMessageControlButtons(messageId, controlsEl);
	}

	// Clear chat history
	function clearChat() {
		if (confirm('Are you sure you want to clear the chat history?')) {
			messages = [];
			localStorage.removeItem('chatHistory');
			renderMessages();
			showStatus('Chat history cleared', 'success');
		}
	}

	// Add a clear chat button to the UI
	function addClearChatButton() {
		const header = document.querySelector('header');
		const clearBtn = document.createElement('button');
		clearBtn.id = 'clear-chat';
		clearBtn.textContent = 'Clear Chat';
		clearBtn.addEventListener('click', clearChat);
		header.appendChild(clearBtn);
	}

	function updateModelOptions() {
		const providerId = apiProviderSelector.value;
		const provider = PROVIDERS.get(providerId);

		if (!provider) {
			console.error(`Provider ${providerId} not found`);
			return;
		}

		modelSelector.innerHTML = '';

		// Add each model from the provider to the selector
		provider.models.forEach(model => {
			const option = document.createElement('option');
			option.value = model.id;
			option.textContent = model.displayName;
			modelSelector.appendChild(option);
		});

		// Select the first model by default if available
		if (provider.models.length > 0) {
			modelSelector.value = provider.models[0].id;
			// Set the temperature to the default for this model
			const defaultModel = provider.models[0];
			temperatureInput.value = defaultModel.defaultTemperature.toFixed(2);
		}
	}

	// Function to save the system prompt
	function saveSystemPrompt() {
		const newPrompt = systemPromptTextarea.value.trim();
		if (newPrompt) {
			SYSTEM_MESSAGE.content = newPrompt;
			localStorage.setItem('systemPrompt', newPrompt);
			showStatus('System prompt updated successfully', 'success');
		} else {
			showStatus('System prompt cannot be empty', 'error');
		}
	}

	// Function to reset the system prompt to default
	function resetSystemPrompt() {
		if (confirm('Are you sure you want to reset the system prompt to default?')) {
			SYSTEM_MESSAGE.content = DEFAULT_SYSTEM_MESSAGE.content;
			systemPromptTextarea.value = DEFAULT_SYSTEM_MESSAGE.content;
			localStorage.removeItem('systemPrompt');
			showStatus('System prompt reset to default', 'success');
		}
	}


	// Add this function to your app.js file
	function setupExpandingSystemPrompt() {
		// Store the original height
		const originalHeight = getComputedStyle(systemPromptTextarea).height;

		// Set a data attribute to store the original height for reference
		systemPromptTextarea.dataset.originalHeight = originalHeight;

		// Add focus event listener
		systemPromptTextarea.addEventListener('focus', () => {
			// Expand the textarea when focused
			systemPromptTextarea.style.height = '300px';
		});

		// Add blur event listener
		systemPromptTextarea.addEventListener('blur', () => {
			// Return to original height when not focused
			systemPromptTextarea.style.height = systemPromptTextarea.dataset.originalHeight;
		});
	}
	function setupExpandingUserInput() {
		// Store the original height
		const originalHeight = getComputedStyle(userInput).height;

		// Set a data attribute to store the original height for reference
		userInput.dataset.originalHeight = originalHeight;

		// Add focus event listener
		userInput.addEventListener('focus', () => {
			// Expand the textarea when focused
			userInput.style.height = '150px'; // You can adjust this value as needed
		});

		// Add blur event listener
		userInput.addEventListener('blur', () => {
			// If the textarea is empty, return to original height when not focused
			if (userInput.value.trim() === '') {
				userInput.style.height = userInput.dataset.originalHeight;
			}
		});

		// Add input event listener to adjust height based on content
		userInput.addEventListener('input', () => {
			// Make sure the height is at least the expanded height when typing
			const minHeight = userInput.matches(':focus') ? '150px' : userInput.dataset.originalHeight;

			// If there's content, keep the expanded height even when blurred
			if (userInput.value.trim() !== '') {
				userInput.style.height = '150px';
			}
		});
	}

	// Delete a single message
	function deleteMessage(messageId) {
		if (confirm('Are you sure you want to delete this message?')) {
			const messageIndex = messages.findIndex(msg => msg.id === messageId);

			if (messageIndex !== -1) {
				// If deleting a user message that has an AI response right after it,
				// also delete the AI response
				if (
					messages[messageIndex].role === 'user' &&
					messageIndex + 1 < messages.length &&
					messages[messageIndex + 1].role === 'assistant'
				) {
					messages.splice(messageIndex, 2); // Remove both messages
				} else {
					messages.splice(messageIndex, 1); // Remove just this message
				}

				// Update localStorage and UI
				localStorage.setItem('chatHistory', JSON.stringify(messages));
				renderMessages();
				showStatus('Message deleted', 'success');
			}
		}
	}

	// Delete all messages from a certain point onwards
	function deleteFromHere(messageId) {
		if (confirm('Are you sure you want to delete this message and all that follow?')) {
			const messageIndex = messages.findIndex(msg => msg.id === messageId);

			if (messageIndex !== -1) {
				messages = messages.slice(0, messageIndex);
				localStorage.setItem('chatHistory', JSON.stringify(messages));
				renderMessages();
				showStatus('Messages deleted', 'success');
			}
		}
	}

	// Create a helper function to generate message control buttons
	function createMessageControlButtons(messageId, controlsEl) {
		// Add edit button
		const editBtn = document.createElement('button');
		editBtn.className = 'icon-button edit-message';
		editBtn.innerHTML = '🖊️';
		editBtn.addEventListener('click', () => startEditing(messageId));
		controlsEl.appendChild(editBtn);

		// Add delete button
		const deleteBtn = document.createElement('button');
		deleteBtn.className = 'icon-button delete-message';
		deleteBtn.innerHTML = '🗑️';
		deleteBtn.addEventListener('click', () => deleteMessage(messageId));
		controlsEl.appendChild(deleteBtn);

		// Add delete-from-here button (only for user messages)
		const message = messages.find(msg => msg.id === parseInt(messageId));
		if (message && message.role === 'user') {
			const deleteFromHereBtn = document.createElement('button');
			deleteFromHereBtn.className = 'icon-button delete-from-here';
			deleteFromHereBtn.innerHTML = '🗑️⬇️';
			deleteFromHereBtn.addEventListener('click', () => deleteFromHere(messageId));
			controlsEl.appendChild(deleteFromHereBtn);
		}

	}

	// Add this function to create and insert the temperature control
	function addTemperatureControl() {
		// Create container for temperature control
		const tempContainer = document.createElement('div');
		tempContainer.className = 'temperature-container';

		// Create label
		const tempLabel = document.createElement('label');
		tempLabel.htmlFor = 'temperature-input';
		tempLabel.textContent = 'Temperature:';

		// Create input
		const tempInput = document.createElement('input'); // Keep this local const
		tempInput.type = 'number';
		tempInput.id = 'temperature-input';
		tempInput.min = '0';
		tempInput.step = '0.01';
		tempInput.value = '0.7'; // Default value

		// Assign the created element to the global variable
		temperatureInput = tempInput;

		// Add elements to container
		tempContainer.appendChild(tempLabel);
		tempContainer.appendChild(tempInput);

		// Find a reliable parent element
		const inputParent = userInput.parentElement;

		// Insert before the user input
		inputParent.insertBefore(tempContainer, userInput);
	}

	// Add a getter for the messages array
	function getMessages() {
		return messages;
	}

	return {
		init: init,
		getMessages: getMessages
	};
})();

// Initialize the app
document.addEventListener('DOMContentLoaded', function () {
	window.RPChat.app.init();
});

</script>
</body>

</html>