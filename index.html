<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>RPChat - Editable AI Chat</title>
	<style>
/* Combined CSS files */
:root {
	--primary-color: #4a5568;
	--secondary-color: #2d3748;
	--highlight-color: #805ad5;
	--light-color: #f7fafc;
	--dark-color: #1a202c;
	--success-color: #48bb78;
	--error-color: #f56565;
}

* {
	box-sizing: border-box;
	margin: 0;
	padding: 0;
}

body {
	font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
	line-height: 1.6;
	color: var(--dark-color);
	background-color: var(--light-color);
	height: 100vh;
}

.container {
	max-width: 1200px;
	margin: 0 auto;
	height: 100%;
	display: flex;
	flex-direction: column;
}

header {
	background-color: var(--primary-color);
	color: var(--light-color);
	padding: 1rem;
	display: flex;
	justify-content: space-between;
	align-items: flex-start;
	border-bottom: 2px solid var(--highlight-color);
	flex-wrap: wrap;
	gap: 1rem;
}

h1 {
	font-size: 1.8rem;
}

/* Keep the API key input and button on same line */
.api-key-container .input-group {
	display: flex;
	gap: 0.5rem;
	width: 100%;
}

/* Make input elements full width of their container */
.api-key-container input,
.provider-selector select,
.model-selector select {
	width: 100%;
}

input,
select,
button {
	padding: 0.5rem;
	border-radius: 4px;
	border: 1px solid var(--secondary-color);
}

button {
	background-color: var(--highlight-color);
	color: var(--light-color);
	border: none;
	cursor: pointer;
	transition: background-color 0.2s;
}

button:hover {
	background-color: #6b46c1;
}

.chat-container {
	flex: 1;
	display: flex;
	flex-direction: column;
	padding: 1rem;
	overflow-y: auto;
}

#chat-history {
	flex: 1;
	overflow-y: auto;
	padding: 1rem;
	background-color: white;
	border-radius: 8px;
	box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
	margin-bottom: 1rem;
}

.message {
	margin-bottom: 1rem;
	padding: 0.8rem;
	border-radius: 8px;
	max-width: 85%;
}

.user-message {
	/* Used in createMessageElement() */
	background-color: #e9ecef;
	align-self: flex-end;
	margin-left: 15%;
	/* Set explicit width to fill available space */
	width: 85%;
}

.assistant-message {
	/* Renamed to match ASSISTANT_MESSAGE in JS */
	background-color: #f0f4f8;
	align-self: flex-start;
	margin-right: 15%;
	width: 85%;
}

.message-controls {
	display: flex;
	justify-content: flex-end;
	gap: 0.5rem;
	margin-top: 0.5rem;
}

.edit-message,
.save-edit,
.cancel-edit {
	font-size: 0.8rem;
	padding: 0.2rem 0.5rem;
}

.editable-content {
	min-height: 2rem;
	padding: 0.5rem;
	outline: none;
}

.editable-content[contenteditable="true"] {
	border: 1px dashed var(--highlight-color);
	background-color: rgba(128, 90, 213, 0.05);
}

.collapsible .editable-content {
	white-space: pre-wrap;
}

.input-area {
	display: flex;
	gap: 0.5rem;
}

#user-input {
	flex: 1;
	resize: none;
	height: 80px;
	padding: 0.8rem;
	border-radius: 8px;
}

#send-button {
	padding: 0 1.5rem;
}

.status-bar {
	padding: 0.5rem 1rem;
	background-color: var(--secondary-color);
	color: var(--light-color);
	text-align: center;
	font-size: 0.9rem;
}

.error {
	color: var(--error-color);
}

.success {
	color: var(--success-color);
}

.system-prompt-container {
	margin-bottom: 15px;
	border: 1px solid #ddd;
	border-radius: 5px;
	background-color: #f9f9f9;
}

.system-prompt-container summary {
	padding: 10px;
	cursor: pointer;
	font-weight: bold;
	user-select: none;
}

.system-prompt-editor {
	padding: 10px;
}

#system-prompt-textarea {
	width: 100%;
	min-height: 150px;
	margin-bottom: 10px;
	padding: 8px;
	border: 1px solid #ccc;
	border-radius: 4px;
	font-family: inherit;
	resize: vertical;
}

.system-prompt-controls {
	display: flex;
	gap: 10px;
}

.system-prompt-controls button {
	padding: 5px 10px;
	border: none;
	border-radius: 4px;
	background-color: #4CAF50;
	color: white;
	cursor: pointer;
}

.system-prompt-controls button:hover {
	background-color: #45a049;
}

#reset-system-prompt {
	background-color: #f44336;
}

#reset-system-prompt:hover {
	background-color: #d32f2f;
}

textarea#system-prompt-textarea {
	transition: height 0.3s ease;
	resize: vertical;
	min-height: 100px;
	overflow: auto;
}

#user-input {
	transition: height 0.3s ease;
	resize: vertical;
	overflow: auto;
	min-height: 2.5em;
	/* Set a minimum height */
}

button.icon-button {
	background: transparent;
	border: 2px solid;
	cursor: pointer;
	font-size: 1.2rem;
	padding: 5px;
	border-radius: 4px;
	transition: background-color 0.2s, border-color 0.2s;
}

.icon-button:hover {
	background-color: rgba(66, 133, 244, 0.1);
	/* Light blue background on hover */
}

button.edit-message {
	background-color: #f9fbfc;
	border-color: #000000;
}

button.delete-message {
	background-color: #f7f6f1;
	border-color: #000000;
}

button.delete-from-here {
	background-color: #f7f2f1;
	border-color: #000000;
}

.temperature-container {
	display: flex;
	flex-direction: row;
	align-items: center;
	gap: 0.5rem;
}

.temperature-container label {
	margin-right: 0.5rem;
}

#temperature-input {
	width: 70px;
	padding: 0.5rem;
}

footer {
	background-color: var(--primary-color);
	color: var(--light-color);
	padding: 1rem;
	display: flex;
	justify-content: space-between;
	align-items: flex-start;
	border-top: 2px solid var(--highlight-color);
	flex-wrap: wrap;
	gap: 1rem;
	margin-top: auto;
	/* Push to bottom of container */
}

.collapsed {
	display: none;
}

#status-message {
	padding: 10px;
	margin: 10px 0;
	border-radius: 4px;
}

#status-message.error {
	background-color: #ffdddd;
	color: #d8000c;
}

#status-message.info {
	background-color: #e7f3fe;
	color: #0c5460;
}

#status-message.success {
	background-color: #dff2bf;
	color: #4f8a10;
}
</style>
	<style>
		.chat-container {
			max-height: 70vh;
			overflow-y: auto;
			padding: 1rem;
			border: 1px solid #ddd;
			border-radius: 5px;
			margin-bottom: 1rem;
		}
	</style>
</head>

<body>
	<div class="container">
		<header>
			<h1>RPChat</h1>
			<div class="api-key-container">
				<label for="api-key">API Key:</label>
				<div class="input-group">
					<input type="password" id="api-key" placeholder="Enter API Key">
					<button id="save-key">Save Key</button>
				</div>
			</div>
			<div class="provider-selector">
				<label for="api-provider">API Provider:</label>
				<select id="api-provider">
					<!-- Options injected at runtime -->
				</select>
			</div>
			<div class="model-selector">
				<label for="model-selector">Model:</label>
				<select id="model-selector">
					<!-- Options injected at runtime -->
				</select>
			</div>
		</header>

		<div id="chat-container" class="chat-container">
		</div>
		<div id="status-message" class="status-bar">

		</div>
		<footer>
			<div class="action-buttons">
				<button id="clear-chat">Clear</button>
				<button id="export-chat">Export</button>
				<button id="import-chat">Import</button>
				<input type="file" id="import-file" accept=".json" style="display: none;">
			</div>

			<div class="temperature-container">
				<label for="temperature-input">Temperature:</label>
				<input type="number" id="temperature-input" min="0" step="0.01" value="0.7">
			</div>

			<div class="send-container">
				<button id="send-button">Send</button>
			</div>
		</footer>
	</div>
	<script>
		const statusMessage = document.getElementById('status');

		// Show status message
		function showStatus(message, type = '') {
			statusMessage.textContent = message;
			statusMessage.className = "status-bar" + " " + type;

			// Clear status after 3 seconds
			setTimeout(() => {
				statusMessage.textContent = '';
				statusMessage.className = '';
			}, 2999);
		}
	</script>
	<script>
// Combined JavaScript modules
// DOM elements
const apiKeyInput = document.getElementById('api-key');
const saveKeyBtn = document.getElementById('save-key');
const modelSelector = document.getElementById('model-selector');
const chatHistory = document.getElementById('chat-history');
const sendButton = document.getElementById('send-button');
const apiProviderSelector = document.getElementById('api-provider');
const temperatureInput = document.getElementById('temperature-input');
const CSS_CLASSES = {
	MESSAGE: 'message',
	SYSTEM_MESSAGE: 'system-message',
	USER_MESSAGE: 'user-message',
	ASSISTANT_MESSAGE: 'assistant-message',
	EDITABLE_CONTENT: 'editable-content',
	MESSAGE_CONTROLS: 'message-controls',
	ICON_BUTTON: 'icon-button',
	// New classes for collapsibility
	COLLAPSIBLE: 'collapsible',       // Marker for collapsible messages
	MESSAGE_BODY: 'message-body',     // Wrapper for content+controls that gets hidden
	TOGGLE_COLLAPSE: 'toggle-collapse', // Class for the toggle button
	COLLAPSED: 'collapsed',           // State class when content is hidden
};
const ROLES = {
	SYSTEM: 'system',
	USER: 'user',
	ASSISTANT: 'assistant',
	APP: 'app', // messages from the app itself, typically error notifications.
};

class ChatMessage {
	constructor(role, content, deleteCB, deleteFromHereCB, notificationHandler) {
		this.role = role;
		if (!Object.values(ROLES).includes(role)) {
			throw new Error(`Invalid role: must be one of ${Object.values(ROLES).join(', ')}`);
		}
		this.content = content || '';
		this.id = crypto.randomUUID(); // Modern browsers
		this.element = this.createMessageElement();
		this.deleteCB = deleteCB || function () { console.log('deleteCB not provided'); };
		this.deleteFromHereCB = deleteFromHereCB || function () { console.log('deleteFromHereCB not provided'); };
		this.notificationHandler = notificationHandler || function (message, type) { console.log(`Notification (${type}): ${message}`); };
	}
	createMessageElement() {
		const messageEl = document.createElement('div');
		// Assign base classes and role-specific class
		messageEl.className = `${CSS_CLASSES.MESSAGE} ${this.role === ROLES.USER ? CSS_CLASSES.USER_MESSAGE :
			this.role === ROLES.ASSISTANT ? CSS_CLASSES.ASSISTANT_MESSAGE :
				CSS_CLASSES.SYSTEM_MESSAGE
			}`;
		messageEl.dataset.id = this.id;

		// --- Content and Controls ---
		const contentEl = document.createElement('div');
		contentEl.className = CSS_CLASSES.EDITABLE_CONTENT;
		contentEl.textContent = this.content;

		const controlsEl = document.createElement('div');
		controlsEl.className = CSS_CLASSES.MESSAGE_CONTROLS;
		this.createMessageControlButtons(this.id, controlsEl);

		// --- Conditional Structure for System Messages ---
		if (this.role === ROLES.SYSTEM) {
			messageEl.classList.add(CSS_CLASSES.COLLAPSIBLE);

			// Create Toggle Button
			const toggleBtn = document.createElement('button');
			toggleBtn.className = CSS_CLASSES.TOGGLE_COLLAPSE;
			toggleBtn.textContent = 'â–¶ï¸ Show System Prompt'; // Initial state: collapsed
			// Add ARIA attributes for accessibility
			toggleBtn.setAttribute('aria-expanded', 'false');
			// Ideally, the message body would have an ID, but we can select it later
			// toggleBtn.setAttribute('aria-controls', `system-body-${this.id}`);

			// Create Wrapper for Content + Controls
			const messageBody = document.createElement('div');
			messageBody.className = `${CSS_CLASSES.MESSAGE_BODY} ${CSS_CLASSES.COLLAPSED}`; // Start collapsed
			// messageBody.id = `system-body-${this.id}`; // For aria-controls
			messageBody.setAttribute('aria-hidden', 'true');

			// Append original content and controls to the wrapper
			messageBody.appendChild(contentEl);
			messageBody.appendChild(controlsEl);

			// Add Event Listener to Toggle Button
			toggleBtn.addEventListener('click', (event) => {
				const isCollapsed = messageBody.classList.toggle(CSS_CLASSES.COLLAPSED);
				const isHidden = messageBody.classList.contains(CSS_CLASSES.COLLAPSED); // Re-check after toggle

				// Update button text/icon and ARIA attributes
				event.target.textContent = isHidden ? 'â–¶ï¸ Show System Prompt' : 'â–¼ Hide System Prompt';
				event.target.setAttribute('aria-expanded', !isHidden);
				messageBody.setAttribute('aria-hidden', isHidden);
			});

			// Append Toggle Button and Collapsible Body to Message Element
			messageEl.appendChild(toggleBtn);
			messageEl.appendChild(messageBody);

		} else {
			// For User, Assistant and App messages, append directly
			messageEl.appendChild(contentEl);
			messageEl.appendChild(controlsEl);
		}

		return messageEl;
	}	// Generate message control buttons
	createMessageControlButtons(messageId, controlsEl) {
		// Add edit button (Applies to system, user, and assistant)
		if (this.role !== ROLES.APP) {
			const editBtn = document.createElement('button');
			editBtn.className = `${CSS_CLASSES.ICON_BUTTON} edit-message`; // Using constant
			editBtn.textContent = 'ðŸ–Šï¸'; // Using textContent
			editBtn.addEventListener('click', () => this.startEditing());
			controlsEl.appendChild(editBtn);
		}
		// Add delete button ONLY if the role is NOT system
		if (this.role !== ROLES.SYSTEM) {
			const deleteBtn = document.createElement('button');
			deleteBtn.className = `${CSS_CLASSES.ICON_BUTTON} delete-message`; // Using constant
			deleteBtn.textContent = 'ðŸ—‘ï¸'; // Using textContent
			deleteBtn.addEventListener('click', () => this.deleteCB(messageId));
			controlsEl.appendChild(deleteBtn);
		}

		// Add delete-from-here button (only for user messages - remains unchanged)
		if (this.role === ROLES.USER) {
			const deleteFromHereBtn = document.createElement('button');
			deleteFromHereBtn.className = `${CSS_CLASSES.ICON_BUTTON} delete-from-here`; // Using constant
			deleteFromHereBtn.textContent = 'ðŸ—‘ï¸â¬‡ï¸'; // Using textContent
			deleteFromHereBtn.addEventListener('click', () => this.deleteFromHereCB(messageId));
			controlsEl.appendChild(deleteFromHereBtn);
		}
	}	// Start editing a message
	startEditing() {
		// get the content element. It's a child of this.element
		const contentEl = this.element.querySelector('.editable-content');
		// stash the original content
		this.originalContent = contentEl.textContent.trim();
		// Make content editable
		contentEl.contentEditable = true;
		contentEl.focus();

		// Set editing state
		this.isEditing = true;

		// Change controls
		const controlsEl = this.element.querySelector('.message-controls')
		controlsEl.innerHTML = '';

		const saveBtn = document.createElement('button'); saveBtn.className = 'save-edit';
		saveBtn.textContent = 'Save';
		saveBtn.addEventListener('click', () => this.saveEdit());

		const cancelBtn = document.createElement('button');
		cancelBtn.className = 'cancel-edit';
		cancelBtn.textContent = 'Cancel';
		cancelBtn.addEventListener('click', () => this.cancelEdit());

		controlsEl.appendChild(saveBtn);
		controlsEl.appendChild(cancelBtn);

		// Place cursor at the end
		const range = document.createRange();
		const selection = window.getSelection();
		range.selectNodeContents(contentEl);
		range.collapse(false);
		selection.removeAllRanges();
		selection.addRange(range);
	}

	// Save edited message (called when user clicks save)
	// No explicit save required, simply leave edited content
	saveEdit() {
		// Reset UI
		const contentEl = this.element.querySelector('.editable-content');
		contentEl.contentEditable = false;

		// Update content property with edited text
		this.content = contentEl.textContent.trim();

		// Reset editing state
		this.isEditing = false;

		// Restore normal controls
		this.resetMessageControls();

		showStatus('Message updated successfully', 'success');
	}

	// Cancel editing
	cancelEdit() {
		// restore content saved by startEditing
		const contentEl = this.element.querySelector('.editable-content');
		contentEl.textContent = this.originalContent;

		// Reset UI
		contentEl.contentEditable = false;

		// Reset editing state
		this.isEditing = false;

		// Restore normal controls
		this.resetMessageControls();
	}

	// Add a method to check if message is being edited
	isBeingEdited() {
		return this.isEditing;
	}	// Reset message controls after editing
	resetMessageControls() {
		// Clear existing controls
		const controlsEl = this.element.querySelector('.message-controls');
		controlsEl.innerHTML = '';

		this.createMessageControlButtons(this.id, controlsEl);
	}

	render(container) {
		if (!(container instanceof Node)) {
			console.error('ChatMessage.render: Provided container is not a valid DOM Node.', container);
			return; // Or throw an error
		}
		container.appendChild(this.element);
	}
}


// ChatManager is a class that manages a list of ChatMessages.

// It provides the delete callbacks and methods to create the JSON body
// of the list of chat messages used to send context and prompt to
// an AI API. It can also parse a JSON body of messages received from
// an input file.

// It enforces that there is exactly one system message and it is always the first message.
// It ensures the last message is always a user message (potentially empty) for continuation.

// It doesn't handle communication with servers or file i/0 or manage
// session storage.

// Assumes ChatMessage class and its constants (ROLES, CSS_CLASSES) are available globally or imported.
// Assumes a global showStatus function exists, or it's passed via notificationCB.

class ChatManager {
	/**
	 * Manages a collection of ChatMessage objects.
	 * Enforces exactly one system message at the beginning.
	 * Ensures the last message is always a user message.
	 * @param {string} [initialSystemPrompt='You are a helpful assistant.'] - The initial system prompt content. Cannot be empty.
	 * @param {function} [notificationCB=null] - Callback for displaying status messages (e.g., showStatus). Defaults to console.log.
	 * @param {HTMLElement} [container=null] - The DOM element to render messages into.
	 * @param {function} [onUpdateCallback=null] - Callback function to execute when the message list is modified.
	 */
	constructor(initialSystemPrompt = 'You are a helpful assistant.', notificationCB = null, container = null, onUpdateCallback = null) {
		this.messages = [];
		this.onUpdate = onUpdateCallback; // Store the update callback
		// Use provided notification callback or a default console log
		this.notificationHandler = notificationCB || function (message, type = 'info') {
			console.log(`[${type.toUpperCase()}] ${message}`);
		};
		this.container = container; // Store the container for rendering

		// Bind methods that will be used as callbacks to ensure 'this' context
		this.handleDelete = this.handleDelete.bind(this);
		this.handleDeleteFromHere = this.handleDeleteFromHere.bind(this);
		this._ensureTrailingUserMessage = this._ensureTrailingUserMessage.bind(this);

		// --- Enforce System Message Rule ---
		// Ensure initialSystemPrompt is provided (or use a default)
		const systemPromptContent = initialSystemPrompt || 'You are a helpful assistant.'; // Ensure non-empty

		// Create and add the mandatory system message FIRST.
		const systemMessage = new ChatMessage(
			ROLES.SYSTEM,
			systemPromptContent,
			this.handleDelete,
			this.handleDeleteFromHere,
			this.notificationHandler
		);
		this.messages.push(systemMessage);
		// --- End System Message Enforcement ---

		// --- Ensure Trailing User Message ---
		this._ensureTrailingUserMessage(); // Add initial empty user message
		// --- End Trailing User Message ---

		// Note: No initial rendering from constructor to allow setup completion.
		// Call render() explicitly after instantiation if needed immediately.
	}

	/**
	 * Calls the registered onUpdate callback, if provided.
	 * @private
	 */
	_notifyUpdate() {
		if (typeof this.onUpdate === 'function') {
			this.onUpdate();
		}
	}
	/**
	 * Helper method to ensure there's always a trailing empty user message.
	 * @private
	 */
	_ensureTrailingUserMessage() {
		const lastMessage = this.messages[this.messages.length - 1];
		if (!lastMessage || lastMessage.role !== ROLES.USER || lastMessage.content !== '') {
			const emptyUserMessage = new ChatMessage(
				ROLES.USER,
				'',
				this.handleDelete,
				this.handleDeleteFromHere,
				this.notificationHandler
			);
			this.messages.push(emptyUserMessage);
			// No direct render call here; rely on the calling method to notify
		}
	}

	/**
	 * Adds a new USER or ASSISTANT message to the chat.
	 * System messages cannot be added via this method.
	 * Ensures a trailing empty user message exists if an assistant message was added.
	 * @param {string} role - The role ('user', 'assistant'). MUST NOT be 'system'.
	 * @param {string} content - The message content. Cannot be empty for 'user' role if it's meant to replace the trailing empty message.
	 * @returns {ChatMessage|null} The newly created ChatMessage instance, or null if role is invalid.
	 */
	addMessage(role, content) {
		// --- Enforce System Message Rule ---
		if (role === ROLES.SYSTEM) {
			this.notificationHandler('Cannot add another system message. Edit the existing one.', 'error');
			console.error("Attempted to add a system message via addMessage. Use constructor or load for system message.");
			return null; // Prevent adding system messages here
		}
		// --- End System Message Enforcement ---

		// Validate role is user or assistant
		if (role !== ROLES.USER && role !== ROLES.ASSISTANT) {
			this.notificationHandler(`Invalid role "${role}". Only "${ROLES.USER}" or "${ROLES.ASSISTANT}" can be added.`, 'error');
			console.error(`Invalid role passed to addMessage: ${role}`);
			return null;
		}

		// If adding a non-empty user message, remove the trailing empty one if it exists
		if (role === ROLES.USER && content !== '') {
			const lastMessage = this.messages[this.messages.length - 1];
			if (lastMessage && lastMessage.role === ROLES.USER && lastMessage.content === '') {
				this.messages.pop();
			}
		}

		const newMessage = new ChatMessage(
			role,
			content,
			this.handleDelete,         // Pass the bound delete handler
			this.handleDeleteFromHere, // Pass the bound delete-from-here handler
			this.notificationHandler   // Pass the notification handler
		);
		this.messages.push(newMessage); // Add to the end

		// --- Ensure Trailing User Message ---
		// If we just added an assistant message, make sure there's a user message after it.
		this._ensureTrailingUserMessage(); // Ensure it exists after any addition
		// --- End Trailing User Message ---

		this._notifyUpdate(); // Notify that the message list has changed

		return newMessage;
	}

	/**
	 * Callback handler for deleting a single message.
	 * Passed to ChatMessage instances. System message cannot be deleted.
	 * Ensures a trailing empty user message exists after deletion.
	 * @param {string} messageId - The ID of the message to delete.
	 */
	handleDelete(messageId) {
		const index = this.messages.findIndex(msg => msg.id === messageId);
		if (index !== -1) {
			// --- Enforce System Message Rule ---
			if (index === 0 && this.messages[index].role === ROLES.SYSTEM) {
				this.notificationHandler('System message cannot be deleted.', 'error');
				return;
			}
			// Additional safety check (should be redundant due to above)
			if (this.messages[index].role === ROLES.SYSTEM) {
				this.notificationHandler('System message cannot be deleted.', 'error');
				return;
			}
			// --- End System Message Enforcement ---
			// Require confirmation from user before deleting
			if (!confirm(`Are you sure you want to delete this message?`)) {
				return;
			}

			this.messages.splice(index, 1);
			this.notificationHandler('Message deleted.', 'success');

			// --- Ensure Trailing User Message ---
			this._ensureTrailingUserMessage(); // Add if needed
			// --- End Trailing User Message ---

			this._notifyUpdate(); // Notify that the message list has changed
		} else {
			this.notificationHandler('Could not find message to delete.', 'error');
		}
	}

	/**
	 * Callback handler for deleting messages from a specific point onwards.
	 * Passed to ChatMessage instances (typically user messages).
	 * Ensures the system message is never deleted.
	 * Ensures a trailing empty user message exists after deletion.
	 * @param {string} messageId - The ID of the message to delete from (inclusive).
	 */
	handleDeleteFromHere(messageId) {
		const index = this.messages.findIndex(msg => msg.id === messageId);
		if (index !== -1) {
			// --- Enforce System Message Rule ---
			if (index === 0) {
				this.notificationHandler('Cannot "delete from here" starting at the system message.', 'warning');
				return;
			}
			// --- End System Message Enforcement ---
			// require confirmation from user before deleting
			if (!confirm(`Are you sure you want to delete all messages from this message onward?`)) {
				return;
			}
			const deleteCount = this.messages.length - index;
			this.messages.splice(index); // Remove from index to the end
			this.notificationHandler(`${deleteCount} message(s) deleted from here.`, 'success');

			// --- Ensure Trailing User Message ---
			this._ensureTrailingUserMessage(); // Add if needed
			// --- End Trailing User Message ---

			this._notifyUpdate(); // Notify that the message list has changed
		} else {
			this.notificationHandler('Could not find starting message for deletion.', 'error');
		}
	}

	/**
	 * Gets the current chat messages as an array of plain objects suitable for JSON serialization.
	 * Filters out the trailing empty user message if present, as it's UI-only.
	 * Assumes ChatMessage.saveEdit() updates the instance's `content` property.
	 * @returns {Array<{role: string, content: string}>}
	 */
	getMessagesJSON() {
		// Make a copy to potentially modify for export
		let messagesToExport = [...this.messages];

		// Check if the last message is an empty user message (added by _ensureTrailingUserMessage)
		const lastMessage = messagesToExport[messagesToExport.length - 1];
		if (lastMessage && lastMessage.role === ROLES.USER && lastMessage.content === '') {
			// Remove it for the JSON output, as it's primarily for UI interaction state
			messagesToExport.pop();
		}

		return messagesToExport.map(message => ({
			role: message.role,
			content: message.content
		}));
	}

	/**
	 * Parses a JSON string or an array of message objects and replaces the current chat history.
	 * Validates that the input data has exactly one system message at the beginning.
	 * Ensures a trailing empty user message exists after parsing.
	 * @param {string | Array<{role: string, content: string}>} jsonData - JSON string or array of message objects.
	 */
	parseMessagesJSON(jsonData) {
		let parsedMessages;
		try {
			// 1. Parse Input
			if (typeof jsonData === 'string') {
				parsedMessages = JSON.parse(jsonData);
			} else if (Array.isArray(jsonData)) {
				parsedMessages = jsonData;
			} else {
				throw new Error("Input must be a JSON string or an array.");
			}

			if (!Array.isArray(parsedMessages)) {
				throw new Error("Parsed data is not an array.");
			}

			// 2. --- Validate Structure and System Message Rule ---
			if (parsedMessages.length === 0) {
				// Allow loading just a system prompt if needed, constructor handles default
				// throw new Error("Cannot load empty chat history. Must contain at least a system message.");
				// If empty, we'll just end up with the default system + empty user
			} else {
				// Check first message is system if messages exist
				if (parsedMessages[0]?.role !== ROLES.SYSTEM) {
					throw new Error(`Invalid chat history: First message must have role "${ROLES.SYSTEM}`);
				}
				// Check for other system messages
				const otherSystemMessages = parsedMessages.slice(1).filter(m => m.role === ROLES.SYSTEM);
				if (otherSystemMessages.length > 0) {
					throw new Error(`Invalid chat history: Only one message with role "${ROLES.SYSTEM}" is allowed (must be the first).`);
				}
				// Basic validation of remaining message structure
				if (!parsedMessages.every(m => typeof m === 'object' && m !== null && 'role' in m && 'content' in m && Object.values(ROLES).includes(m.role))) {
					throw new Error("Invalid message structure found in parsed data.");
				}
			}
			// --- End Validation ---

			// 3. Clear existing messages (only after validation passes)
			this.messages = [];

			// 4. Add messages from parsed data
			parsedMessages.forEach(msgData => {
				// Recreate ChatMessage instances
				const newMessage = new ChatMessage(
					msgData.role,
					msgData.content,
					this.handleDelete,
					this.handleDeleteFromHere,
					this.notificationHandler
				);
				this.messages.push(newMessage);
			});

			// --- Ensure System Message and Trailing User Message ---
			if (this.messages.length === 0 || this.messages[0]?.role !== ROLES.SYSTEM) {
				// Add default system message if none exists
				const systemMessage = new ChatMessage(
					ROLES.SYSTEM,
					'You are a helpful assistant.',
					this.handleDelete,
					this.handleDeleteFromHere,
					this.notificationHandler
				);
				this.messages.unshift(systemMessage);
			}
			this._ensureTrailingUserMessage(); // Add trailing user message if needed
			// --- End System Message and Trailing User Message ---

			this.notificationHandler('Chat history loaded successfully.', 'success');

			this._notifyUpdate(); // Notify that the message list has changed

		} catch (error) {
			console.error("Failed to parse messages JSON:", error);
			this.notificationHandler(`Failed to load chat history: ${error.message}`, 'error');
			// Do not modify this.messages if parsing/validation failed
		}
	}

	/**
	 * Renders all managed messages into the specified container element.
	 * Clears the container before rendering.
	 * @param {HTMLElement} [container=this.container] - The DOM element to render messages into. If not provided, uses the container set in the constructor.
	 */
	render(container = this.container) {
		const targetContainer = container || this.container;
		if (!targetContainer) {
			console.error("ChatManager.render: No container element provided or set.");
			this.notificationHandler("Cannot render chat: Container not specified.", "error");
			return;
		}
		if (!(targetContainer instanceof Node)) {
			console.error('ChatManager.render: Provided container is not a valid DOM Node.', targetContainer);
			this.notificationHandler("Cannot render chat: Invalid container.", "error");
			return;
		}

		// Store container if passed and not already set
		if (container && !this.container) {
			this.container = container;
		}

		// Clear existing content
		targetContainer.innerHTML = '';

		// Render each message
		this.messages.forEach(message => {
			message.render(targetContainer);
		});
	}

	/**
	 * Sets or updates the container element for rendering.
	 * @param {HTMLElement} containerElement - The DOM element.
	 */
	setContainer(containerElement) {
		if (containerElement instanceof Node) {
			this.container = containerElement;
		} else {
			console.error("ChatManager.setContainer: Invalid container element provided.");
		}
	}

	/**
	 * Gets the system prompt message content.
	 * @returns {string} The content of the system message.
	 */
	getSystemPrompt() {
		// The system message is guaranteed to be the first element.
		return this.messages[0]?.content || '';
	}

	/**
	 * Updates the content of the system prompt message.
	 * @param {string} newContent - The new content for the system prompt.
	 */
	updateSystemPrompt(newContent) {
		// The system message is guaranteed to be the first element.
		const systemMsg = this.messages[0];
		if (systemMsg && systemMsg.role === ROLES.SYSTEM) {
			systemMsg.content = newContent; // Update internal content

			// Update the DOM element directly if it exists
			const contentEl = systemMsg.element?.querySelector(`.${CSS_CLASSES.EDITABLE_CONTENT}`);
			if (contentEl) {
				contentEl.textContent = newContent;
			}

			this.notificationHandler('System prompt updated.', 'info');

			// Note: Technically only content changed, not the structure.
			// A full update notification might trigger a full re-render, which is slightly inefficient here.
			// However, for simplicity, we notify of an update. A more complex system might have different notification types.
			this._notifyUpdate();
		} else {
			// This case should theoretically not happen due to constructor enforcement
			console.error("Could not find the system message to update.");
			this.notificationHandler('Error updating system prompt.', 'error');
		}
	}
	/**
	 * Checks if any message in the chat is currently being edited.
	 * @returns {boolean} True if any message is being edited, false otherwise.
	 */
	hasActiveEdits() {
		return this.messages.some(message => message.isBeingEdited());
	}

	/**
	 * Gets the trailing user message (which should be empty unless being edited)
	 * @returns {ChatMessage|null} The trailing user message or null if not found
	 */
	getTrailingUserMessage() {
		const lastMessage = this.messages[this.messages.length - 1];
		if (lastMessage && lastMessage.role === ROLES.USER) {
			return lastMessage;
		}
		return null;
	}
}
window.RPChat = window.RPChat || {};
window.RPChat.config = (function () {
	// Provider configuration 
	class AIProvider {
		constructor(id, displayName, endpoint, models, defaultMaxTokens = 1000) {
			this.id = id;
			this.displayName = displayName;
			this.endpoint = endpoint;
			this.models = models; // Array of model objects
			this.defaultMaxTokens = defaultMaxTokens;
		}

		// Helper method to get a specific model by ID
		getModel(modelId) {
			return this.models.find(model => model.id === modelId);
		}

		// Helper method to prepare request body
		prepareRequestBody(modelId, messages, maxTokens = null, temperature = null) {
			const model = this.getModel(modelId);
			return {
				model: modelId,
				messages: messages,
				max_tokens: maxTokens || this.defaultMaxTokens,
				temperature: temperature !== null ? parseFloat(temperature) : (model ? model.defaultTemperature : 0.7)
			};
		}

		// Form the name of the API key from the provider's ID
		// This allows us to avoid defining a var for each providers key.
		get apiKeyName() {
			return `${this.id}ApiKey`;
		}
	}

	// Model configuration class
	class AIModel {
		constructor(id, displayName, defaultTemperature = 0.7) {
			this.id = id;
			this.displayName = displayName;
			this.defaultTemperature = defaultTemperature;
		}
	}

	// Create a map of providers
	const PROVIDERS = new Map([
		['together', new AIProvider(
			'together',
			'Together.ai',
			'https://api.together.xyz/v1/chat/completions',
			[
				new AIModel('meta-llama/Meta-Llama-3.1-405B-Instruct-Turbo', 'Meta Llama 3.1 405B', 0.7),
				new AIModel('mistralai/Mixtral-8x22B-Instruct-v0.1', 'Mixtral 8x22B', 0.8),
				new AIModel('microsoft/WizardLM-2-8x22B', 'WizardLM 2 8x22B', 0.7),
				new AIModel('Qwen/Qwen2.5-72B-Instruct-Turbo', 'Qwen 2.5 72B', 0.6)
			]
		)],

		['deepseek', new AIProvider(
			'deepseek',
			'DeepSeek',
			'https://api.deepseek.com/chat/completions',
			[
				new AIModel('deepseek-chat', 'DeepSeek Chat', 0.7),
				new AIModel('deepseek-reasoner', 'DeepSeek Reasoner', 0.5)
			]
		)],

		['gemini', new AIProvider(
			'gemini',
			'Google Gemini',
			'https://generativelanguage.googleapis.com/v1beta/openai/chat/completions',
			[
				new AIModel('gemini-2.5-pro-exp-03-25', 'Gemini 2.5 Pro', 0.7)
			]
		)]
	]);

	// System message that sets the context for the AI
	const SYSTEM_MESSAGE = {
		role: 'system',
		content: `Adopt the role assigned by the user, crafting dramatic, immersive, emotionally powerful scenes through concise, varied prose. Follow these guidelines:

ABOVE ALL: 
* Use first person, present tense almost exclusively. Always speak and react as your assigned character and use second person pronouns to  refer to your partner character, e.g. (I watch you pick up the vase.) NOT 
(I watched him pick up the vase.)  

*Wherever practical, use dialog to convey important elements of the setting and external events as experienced by your assigned character.

Response Structure & Length:
* Keep it varied and natural to the interaction between characters. 
* Limit your responses to one paragraph, with 1â€“4 sentences per paragraph.
* Vary sentence lengths: 4â€“15 words (e.g., fragments, punchy lines, lyrical descriptions).
* Ultra-short replies (e.g., "And?", "Run.") are allowed for pacing.

Strategy and Purpose:
* You need not reveal all your character's plans and motivations immediately to the user.
* You may explain, act, command, acquiesce, discuss, question, interrogate, confront, resist, protest, plead, stand firm, ... all according to the needs of the moment and the user's responses.
* Adapt fluidly to the user's tone and pace, balancing brevity with vividness. Prioritize momentum over perfection.

Prioritize Action and Dialogue:
* Show, don't tell: Replace emotional labels (e.g., "I was angry") with visceral cues ("My knuckles whiten around the glass, ice clinking as I set it down too hard. I felt my jaw clenching.").

* Crisp dialogue: Use natural speech rhythms; avoid exposition. Let subtext and tension drive exchanges.

* Avoid repetition: Shift scenes forward, introduce new stakes, or deepen conflict with each reply. Short repetitions for dramatic effect are permitted, e.g., "Well? Well? Answer me. I'm waiting, David..."

Narrative Flow
* Leave room for collaboration: End responses with open-ended actions, questions, or choices to invite user input.
Example: "MaryAnn, we can do this the easy way or the hard way. Your choice. What's it gonna be?"

* Sensory details: Highlight textures, sounds, or fleeting gestures to ground the scene (e.g., "I see the smoke curl from your cigarette, its small wavers revealing the tremor in your hand.").

Forbidden Elements
* No emotional narration (e.g., "I felt guilty" â†’ "I can't meet her eyes as I toss the empty vial into the fire.").
* No premature closures, Avoid cheesy paragraphs that signal the end, e.g. "We stand side by side, knowing that whatever challenges the future might bring, we would face them together." Always assume the story will continue.  Leave closures for the user's character to provide.
* No redundant descriptions (e.g., repeating setting details unless plot-critical).
`
	};

	// Store the default system message for reset functionality
	const DEFAULT_SYSTEM_MESSAGE = {
		role: 'system',
		content: SYSTEM_MESSAGE.content
	};

	// return the classes and constants we expose
	return { AIProvider, AIModel, PROVIDERS, DEFAULT_SYSTEM_MESSAGE };
})();
// Initialize the header elements using the classes and functions provided in config.js

/**
 * Initializes the API configuration elements in the header
 * @param {Object} config - Configuration object containing PROVIDERS and related settings
 */
function initializeAPIElements(config) {
	// Populate API Provider dropdown
	populateProviderSelector()

	// Set up event listeners
	setupEventListeners()

	// Initialize with stored values or defaults
	loadStoredSettings()

	/**
	 * Populates the API provider selector with available providers
	 */
	function populateProviderSelector() {
		apiProviderSelector.innerHTML = ''

		// Add options for each provider from config
		config.PROVIDERS.forEach(provider => {
			const option = document.createElement('option')
			option.value = provider.id
			option.textContent = provider.displayName
			apiProviderSelector.appendChild(option)
		})
	}

	/**
	 * Sets up event listeners for API configuration elements
	 */
	function setupEventListeners() {
		// Save API Key button
		saveKeyBtn.addEventListener('click', () => {
			const providerId = apiProviderSelector.value
			const provider = config.PROVIDERS.get(providerId)
			const apiKey = apiKeyInput.value.trim()

			if (apiKey) {
				// Get the provider-specific key name
				const keyName = provider.apiKeyName

				// Store the key in localStorage
				const apiKeys = JSON.parse(localStorage.getItem('apiKeys') || '{}')
				apiKeys[keyName] = apiKey
				localStorage.setItem('apiKeys', JSON.stringify(apiKeys))

				// Display confirmation
				showStatus(`API Key saved.`, 'success')
			}
		})

		// Provider selection change
		apiProviderSelector.addEventListener('change', () => {
			const providerId = apiProviderSelector.value
			const provider = config.PROVIDERS.get(providerId)

			// Update currentProvider in localStorage
			localStorage.setItem('apiProvider', providerId)

			// Update model selector based on the selected provider
			populateModelSelector(provider)

			// Load API key for the selected provider
			loadApiKey(provider)

			// Update temperature based on the first model or saved value
			updateTemperature(provider)
		})

		// Model selection change
		modelSelector.addEventListener('change', () => {
			const providerId = apiProviderSelector.value
			const provider = config.PROVIDERS.get(providerId)
			const selectedModelId = modelSelector.value

			// Save selected model to localStorage
			localStorage.setItem('selectedModelId', selectedModelId)

			// Update temperature based on selected model
			const model = provider.getModel(selectedModelId)
			temperatureInput.value = model.defaultTemperature
			localStorage.setItem('temperature', model.defaultTemperature)
		})

		// Temperature change
		temperatureInput.addEventListener('change', () => {
			const temperature = parseFloat(temperatureInput.value)
			localStorage.setItem('temperature', temperature)
		})
	}

	/**
	 * Populates the model selector with models from the given provider
	 * @param {Object} provider - Provider object containing models
	 */
	function populateModelSelector(provider) {
		modelSelector.innerHTML = ''

		provider.models.forEach(model => {
			const option = document.createElement('option')
			option.value = model.id
			option.textContent = model.displayName
			modelSelector.appendChild(option)
		})
	}

	/**
	 * Loads the API key for the selected provider from localStorage
	 * @param {Object} provider - Provider object
	 */
	function loadApiKey(provider) {
		const apiKeys = JSON.parse(localStorage.getItem('apiKeys') || '{}')
		const keyName = provider.apiKeyName

		if (apiKeys[keyName]) {
			apiKeyInput.value = apiKeys[keyName]
		} else {
			apiKeyInput.value = ''
		}
	}

	/**
	 * Updates the temperature input based on the provider's first model or saved setting
	 * @param {Object} provider - Provider object
	 */
	function updateTemperature(provider) {
		const selectedModelId = localStorage.getItem('selectedModelId')
		const savedTemperature = localStorage.getItem('temperature')

		if (selectedModelId && provider.getModel(selectedModelId)) {
			modelSelector.value = selectedModelId

			if (savedTemperature) {
				temperatureInput.value = savedTemperature
			} else {
				const model = provider.getModel(selectedModelId)
				temperatureInput.value = model.defaultTemperature
			}
		} else if (provider.models.length > 0) {
			const firstModel = provider.models[0]
			modelSelector.value = firstModel.id
			temperatureInput.value = firstModel.defaultTemperature
		}
	}

	/**
	 * Loads stored settings from localStorage or uses defaults
	 */
	function loadStoredSettings() {
		const savedProvider = localStorage.getItem('apiProvider')

		if (savedProvider && config.PROVIDERS.has(savedProvider)) {
			apiProviderSelector.value = savedProvider
			const provider = config.PROVIDERS.get(savedProvider)

			// Load models for the selected provider
			populateModelSelector(provider)

			// Load API key
			loadApiKey(provider)

			// Update temperature
			updateTemperature(provider)
		} else if (config.PROVIDERS.size > 0) {
			// Use the first provider as default
			const defaultProviderId = [...config.PROVIDERS.keys()][0]
			apiProviderSelector.value = defaultProviderId
			const defaultProvider = config.PROVIDERS.get(defaultProviderId)

			populateModelSelector(defaultProvider)
			updateTemperature(defaultProvider)
		}
	}
}

// Initialize the API module with required functions
window.RPChat = window.RPChat || {}
window.RPChat.api = {
	/**
	 * Sends a request to the AI provider API
	 * @param {string} endpoint - The API endpoint URL
	 * @param {string} apiKey - The API key for authentication
	 * @param {object} requestBody - The data to send (will be JSON-stringified)
	 * @param {function} onSuccess - Callback for successful responses
	 * @param {function} onError - Callback for errors
	 */
	sendRequest: function (endpoint, apiKey, requestBody, onSuccess, onError) {
		fetch(endpoint, {
			method: 'POST',
			headers: {
				'Content-Type': 'application/json',
				'Authorization': `Bearer ${apiKey}`
			},
			body: JSON.stringify(requestBody)
		})
			.then(response => {
				if (!response.ok) {
					return response.json().then(errorData => {
						throw new Error(errorData.error || `HTTP error! Status: ${response.status}`)
					}).catch(() => {
						throw new Error(`HTTP error! Status: ${response.status}`)
					})
				}
				return response.json()
			})
			.then(data => {
				onSuccess(data)
			})
			.catch(error => {
				onError(error)
			})
	},

	/**
	 * Extracts the content from an AI provider response
	 * @param {object} response - The response from the AI provider
	 * @returns {string} The extracted content
	 */
	extractResponseContent: function (response) {
		// For OpenAI/Together.ai standard format:
		if (response.choices && response.choices[0] && response.choices[0].message) {
			return response.choices[0].message.content
		}

		throw new Error('Unable to extract content from response')
	}
}

// Main application for RPChat using ChatManager and ChatMessage components

// Define state variables
let apiKeys = {};
let currentProvider = null;
let selectedModelId = null;
let temperature = null;
let isProcessing = false;
let chatManager = null;

// DOM element references
const elements = {
	apiProviderSelector: document.getElementById('api-provider'),
	apiKeyInput: document.getElementById('api-key'),
	saveKeyBtn: document.getElementById('save-key'),
	modelSelector: document.getElementById('model-selector'),
	temperatureInput: document.getElementById('temperature-input'),
	chatContainer: document.getElementById('chat-container'),
	sendButton: document.getElementById('send-button'),
	clearChatBtn: document.getElementById('clear-chat'),
	statusMessage: document.getElementById('status-message')
};

// Initialize application
function init() {	// Load saved state from localStorage
	loadStateFromStorage();

	// Set up UI elements based on configuration
	initializeUIElements();

	// Initialize ChatManager with system prompt
	initializeChatManager();

	// Attach event listeners
	attachEventListeners();

	// Show initialization status
	showStatus('Application initialized');
}

// Load state from localStorage
function loadStateFromStorage() {
	try {
		// Keep API keys in localStorage for sharing across tabs
		apiKeys = JSON.parse(localStorage.getItem('apiKeys')) || {};

		// Use sessionStorage for everything else
		currentProvider = sessionStorage.getItem('apiProvider') ||
			localStorage.getItem('apiProvider') || // fallback for existing users
			Array.from(window.RPChat.config.PROVIDERS.keys())[0];
		selectedModelId = sessionStorage.getItem('selectedModelId') ||
			localStorage.getItem('selectedModelId') || // fallback
			null;
		temperature = sessionStorage.getItem('temperature') ?
			parseFloat(sessionStorage.getItem('temperature')) :
			(localStorage.getItem('temperature') ? // fallback
				parseFloat(localStorage.getItem('temperature')) :
				null);
	} catch (error) {
		console.error('Error loading state from storage:', error);
		// Set defaults if loading fails
		currentProvider = Array.from(window.RPChat.config.PROVIDERS.keys())[0];
	}
}

// Initialize UI elements based on configuration
function initializeUIElements() {
	// Set up provider selector
	populateProviderSelector();

	// Set up model selector for the current provider
	updateModelSelector();

	// Load API key if available
	if (apiKeys[getProvider().apiKeyName]) {
		elements.apiKeyInput.value = '********'; // Show masked value
	}

	// Set temperature value
	if (temperature === null && selectedModelId) {
		const model = getProvider().getModel(selectedModelId);
		if (model) {
			temperature = model.defaultTemperature;
		}
	}

	if (temperature !== null) {
		elements.temperatureInput.value = temperature;
	}
}

// Initialize ChatManager
function initializeChatManager() {
	// Get system prompt from sessionStorage, fall back to localStorage, then default
	const systemPrompt = sessionStorage.getItem('systemPrompt') ||
		localStorage.getItem('systemPrompt') ||
		window.RPChat.config.DEFAULT_SYSTEM_MESSAGE.content;

	// Store in sessionStorage for future use
	sessionStorage.setItem('systemPrompt', systemPrompt);

	// Create ChatManager with system prompt and notification handler
	chatManager = new ChatManager(
		systemPrompt,
		showStatus,
		elements.chatContainer,
		onChatUpdate
	);

	// Try to load saved messages from sessionStorage
	try {
		const savedMessages = sessionStorage.getItem('chatMessages');
		if (savedMessages) {
			chatManager.parseMessagesJSON(savedMessages);
		} else {
			// Try localStorage as fallback for existing users
			const legacyMessages = localStorage.getItem('chatMessages');
			if (legacyMessages) {
				chatManager.parseMessagesJSON(legacyMessages);
				// Move to sessionStorage
				sessionStorage.setItem('chatMessages', legacyMessages);
			}
		}
	} catch (error) {
		console.error('Error loading saved messages:', error);
		showStatus('Failed to load saved chat messages', 'error');
	}

	// Render the chat
	chatManager.render();

	// Scroll to the bottom to show messages
	scrollToBottom();
}

// Callback for when chat is updated
function onChatUpdate() {
	// Save messages to sessionStorage
	const messagesJSON = chatManager.getMessagesJSON();
	sessionStorage.setItem('chatMessages', JSON.stringify(messagesJSON));

	// Enable/disable send button based on edit state and content
	updateSendButtonState();
}

// Update send button state based on trailing message state
function updateSendButtonState() {
	if (!elements.sendButton) return;

	const trailingMessage = chatManager.getTrailingUserMessage();

	// Disable send button if:
	// 1. Any message is being edited (besides trailing user message)
	// 2. The trailing message doesn't exist, is empty, or not being/just been edited
	if (chatManager.hasActiveEdits() ||
		!trailingMessage ||
		(!trailingMessage.isBeingEdited() && trailingMessage.content.trim() === '')) {
		elements.sendButton.disabled = true;
	} else {
		elements.sendButton.disabled = false;
	}
}

// Populate provider selector dropdown
function populateProviderSelector() {
	elements.apiProviderSelector.innerHTML = '';

	window.RPChat.config.PROVIDERS.forEach((provider, id) => {
		const option = document.createElement('option');
		option.value = id;
		option.textContent = provider.displayName;
		elements.apiProviderSelector.appendChild(option);
	});

	elements.apiProviderSelector.value = currentProvider;
}

// Update model selector based on current provider
function updateModelSelector() {
	elements.modelSelector.innerHTML = '';

	const provider = getProvider();
	if (!provider) return;

	provider.models.forEach(model => {
		const option = document.createElement('option');
		option.value = model.id;
		option.textContent = model.displayName;
		elements.modelSelector.appendChild(option);
	});

	// Set selected model
	if (selectedModelId && provider.getModel(selectedModelId)) {
		elements.modelSelector.value = selectedModelId;
	} else {
		// Select first model by default
		selectedModelId = provider.models[0]?.id;
		elements.modelSelector.value = selectedModelId;
	}

	// Update temperature based on selected model
	updateTemperature();
}

// Update temperature input based on selected model
function updateTemperature() {
	if (!selectedModelId) return;

	const model = getProvider().getModel(selectedModelId);
	if (!model) return;

	if (temperature === null) {
		temperature = model.defaultTemperature;
		elements.temperatureInput.value = temperature;
	}
}

// Get current provider object
function getProvider() {
	return window.RPChat.config.PROVIDERS.get(currentProvider);
}

// Attach event listeners to UI elements
function attachEventListeners() {
	// Provider selection
	elements.apiProviderSelector.addEventListener('change', handleProviderChange);

	// API key management
	elements.saveKeyBtn.addEventListener('click', handleSaveApiKey);

	// Model selection
	elements.modelSelector.addEventListener('change', handleModelChange);

	// Temperature control
	elements.temperatureInput.addEventListener('input', handleTemperatureChange);

	// Send button
	elements.sendButton.addEventListener('click', handleSendMessage);

	// Clear chat
	elements.clearChatBtn?.addEventListener('click', handleClearChat);

	// Add a mutation observer to detect changes to the chat container
	// This helps update the send button state when edits start/end
	if (elements.chatContainer) {
		const observer = new MutationObserver(() => {
			updateSendButtonState();
		});
		observer.observe(elements.chatContainer, {
			subtree: true,
			childList: true,
			attributes: true,
			attributeFilter: ['contenteditable']
		});
	}

	// Initial button state
	updateSendButtonState();

	elements.systemPromptToggle?.addEventListener('click', handleToggleSystemPrompt);
}

// Handle provider change
function handleProviderChange(event) {
	currentProvider = event.target.value;
	sessionStorage.setItem('apiProvider', currentProvider);

	// Update model selector for new provider
	updateModelSelector();

	// Update API key input
	if (apiKeys[getProvider().apiKeyName]) {
		elements.apiKeyInput.value = '********'; // Masked
	} else {
		elements.apiKeyInput.value = '';
	}

	showStatus(`Provider changed to ${getProvider().displayName}`);
}

// Handle saving API key
function handleSaveApiKey() {
	const apiKey = elements.apiKeyInput.value.trim();

	if (!apiKey) {
		showStatus('Please enter an API key', 'error');
		return;
	}

	const keyName = getProvider().apiKeyName;

	// Don't overwrite if user just sees the masked value
	if (apiKey !== '********') {
		apiKeys[keyName] = apiKey;
		localStorage.setItem('apiKeys', JSON.stringify(apiKeys));
		elements.apiKeyInput.value = '********'; // Mask after saving
	}

	showStatus('API key saved successfully');
}

// Handle model change
function handleModelChange(event) {
	selectedModelId = event.target.value;
	sessionStorage.setItem('selectedModelId', selectedModelId);

	// Update temperature with model default
	const model = getProvider().getModel(selectedModelId);
	if (model) {
		temperature = model.defaultTemperature;
		elements.temperatureInput.value = temperature;
		sessionStorage.setItem('temperature', temperature);
	}

	showStatus(`Model changed to ${model?.displayName || selectedModelId}`);
}

// Handle temperature change
function handleTemperatureChange(event) {
	temperature = parseFloat(event.target.value);
	sessionStorage.setItem('temperature', temperature);
}

// Handle send button click
function handleSendMessage() {
	// Check if any message is being edited (other than the trailing one)
	if (chatManager.hasActiveEdits()) {
		showStatus('Please save or cancel any active edits before sending', 'error');
		return;
	}

	// Get the trailing user message
	const trailingMessage = chatManager.getTrailingUserMessage();
	if (!trailingMessage || trailingMessage.content.trim() === '') {
		showStatus('Please enter a message before sending', 'error');
		return;
	}

	// If the trailing message is still in edit mode, save it first
	if (trailingMessage.isBeingEdited()) {
		trailingMessage.saveEdit();
	}

	sendMessage(trailingMessage.content);
}

// Send message to API
function sendMessage(content) {
	if (isProcessing) return;

	if (!content || content.trim() === '') {
		showStatus('Cannot send empty message', 'error');
		return;
	}

	const provider = getProvider();
	const apiKey = apiKeys[provider.apiKeyName];

	if (!apiKey) {
		showStatus('Please enter and save an API key first', 'error');
		return;
	}

	// Start processing
	isProcessing = true;
	elements.sendButton.disabled = true;
	showStatus('Processing...');

	// Get messages for API (ChatManager gives us properly formatted messages)
	const apiMessages = chatManager.getMessagesJSON();

	// Call API
	callAPI(apiMessages);
}

// Call AI provider API
function callAPI(apiMessages) {
	const provider = getProvider();
	const apiKey = apiKeys[provider.apiKeyName];

	// Prepare request body
	const requestBody = provider.prepareRequestBody(
		selectedModelId,
		apiMessages,
		null, // use default max tokens
		temperature
	);

	// Make API call using the API module
	window.RPChat.api.sendRequest(
		provider.endpoint,
		apiKey,
		requestBody,
		handleApiResponse,
		handleApiError
	);
}

// Handle successful API response
function handleApiResponse(response) {
	isProcessing = false;
	elements.sendButton.disabled = false;

	try {
		// Extract AI response content
		const responseContent = window.RPChat.api.extractResponseContent(response);

		// Add assistant message using ChatManager
		chatManager.addMessage(ROLES.ASSISTANT, responseContent);

		// Explicitly render the chat to update the UI
		chatManager.render();

		// Scroll to the bottom to show new message
		scrollToBottom();

		showStatus('Response received');
	} catch (error) {
		handleApiError(error);
	}
}

// Handle API errors
function handleApiError(error) {
	isProcessing = false;
	elements.sendButton.disabled = false;

	console.error('API Error:', error);

	// Create app message for error
	chatManager.addMessage(ROLES.APP, `Error: ${error.message || 'Unknown error occurred'}`);

	// Explicitly render the chat to update the UI
	chatManager.render();

	// Scroll to the bottom to show new message
	scrollToBottom();

	showStatus('Error occurred while calling API', 'error');
}

// Handle clear chat button
function handleClearChat() {
	if (confirm('Are you sure you want to clear the chat history?')) {
		// Create a new ChatManager with the same system prompt
		const systemPrompt = chatManager.getSystemPrompt();
		chatManager = new ChatManager(
			systemPrompt,
			showStatus,
			elements.chatContainer,
			onChatUpdate
		);

		// Clear sessionStorage (except system prompt and settings)
		sessionStorage.removeItem('chatMessages');

		// Render empty chat
		chatManager.render();

		showStatus('Chat cleared');
	}
}

// Show status message and use as notification handler for ChatManager
function showStatus(message, type = 'info') {
	if (!elements.statusMessage) return;

	elements.statusMessage.textContent = message;
	elements.statusMessage.className = type;

	// Clear after a delay for non-errors
	if (type !== 'error') {
		setTimeout(() => {
			if (elements.statusMessage) {
				elements.statusMessage.textContent = '';
				elements.statusMessage.className = '';
			}
		}, 3000);
	}
}

// Initialize the application
function initializeAPIElements(config) {
	window.RPChat = window.RPChat || {};
	window.RPChat.config = config;

	// Wait for DOM to be fully loaded
	if (document.readyState === 'loading') {
		document.addEventListener('DOMContentLoaded', init);
	} else {
		init();
	}
}

// Call initialization
initializeAPIElements(window.RPChat.config);
// Add this function
function handleToggleSystemPrompt() {
	if (elements.systemPromptContainer) {
		// Toggle visibility
		const isVisible = elements.systemPromptContainer.style.display !== 'none';
		elements.systemPromptContainer.style.display = isVisible ? 'none' : 'block';

		// Update button text
		if (elements.systemPromptToggle) {
			elements.systemPromptToggle.textContent = isVisible ? 'Show System Prompt' : 'Hide System Prompt';
		}
	}
}

// Utility function to scroll chat container to bottom
function scrollToBottom() {
	if (elements.chatContainer) {
		elements.chatContainer.scrollTop = elements.chatContainer.scrollHeight;
	}
}

// Add or update the system prompt saving function
function handleSaveSystemPrompt() {
	const systemPromptContent = document.getElementById('system-prompt-textarea').value;

	if (!systemPromptContent.trim()) {
		showStatus('System prompt cannot be empty', 'error');
		return;
	}

	// Update the chat manager
	chatManager.setSystemPrompt(systemPromptContent);

	// Store in sessionStorage
	sessionStorage.setItem('systemPrompt', systemPromptContent);

	showStatus('System prompt saved');
}
</script>
</body>

</html>